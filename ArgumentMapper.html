<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Argument Rings — Visual Reasoning Tool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style> 
    :root{
  --bg:#f8fafc;
  --panel:#ffffff;
  --ink:#0f172a;
  --muted:#64748b;
  --muted-2:#94a3b8;
  --accent:#2563eb;
  --danger:#ef4444;
  --ok:#16a34a;
  --ring-gap:2.5;
  --ring-width:64px;
  --shadow:0 8px 24px rgba(2,6,23,0.08);
  --radius:14px;
  --header-height:60px;
  --categories-bar-height:66px;
}

* { box-sizing: border-box; }
html, body { height: 100%; }
body {
  margin: 0;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
  color: var(--ink);
  background: var(--bg);
}

.app-header{
  display:flex; align-items:center; justify-content:space-between;
  padding:10px 12px; background:#fff; box-shadow: var(--shadow); position: sticky; top:0; z-index:10;
}
.app-header button{ margin-right:8px; }

/* Categories Bar */
.categories-bar{
  background:#fff; box-shadow: var(--shadow); padding:12px;
  display:flex; align-items:flex-start; gap:12px;
  position: sticky; top:var(--header-height); z-index:9;
}
.category-controls{
  display:flex; align-items:center; gap:8px; flex-shrink:0;
}
.category-controls input[type="text"],
.category-controls input#new-cat-name{
  border:1px solid #e2e8f0; border-radius:8px; padding:6px 10px; outline:none; min-width:160px;
}
.category-controls input:focus{ border-color:var(--accent); }
.category-controls input[type="color"],
.category-controls input#new-cat-color{
  width:40px; height:40px; padding:4px; border:1px solid #e2e8f0; border-radius:8px; cursor:pointer;
}
.category-controls button{
  white-space:nowrap;
}
.category-list-horizontal{
  display:flex; flex-wrap:wrap; gap:8px; align-items:center; flex:1;
}
.category-horizontal{
  display:flex; align-items:center; gap:6px;
  background:#f8fafc; border:1px solid #e2e8f0; border-radius:8px; padding:6px 10px;
  flex-shrink:0;
  transition: opacity 0.2s ease, transform 0.2s ease;
}
.category-horizontal.dragging{
  opacity:0.5;
}
.drag-handle{
  display:flex; flex-direction:column; gap:2px; cursor:grab; padding:2px;
  opacity:0.4; transition: opacity 0.2s ease;
}
.category-horizontal:hover .drag-handle{
  opacity:0.7;
}
.drag-handle:active{
  cursor:grabbing;
}
.drag-handle-line{
  width:12px; height:2px; background:#64748b; border-radius:1px;
}
.category-drag-placeholder{
  width:4px;
  min-width:4px;
  height:40px;
  background:var(--accent);
  border-radius:2px;
  flex-shrink:0;
  animation: pulse-placeholder 0.8s ease-in-out infinite;
}
@keyframes pulse-placeholder {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 1; }
}
.category-horizontal input[type="color"]{ 
  width:24px; height:24px; padding:0; border:none; background:none; cursor:pointer;
}
.category-horizontal .name{ 
  font-size:14px; font-weight:500; min-width:80px;
}
.category-horizontal .name[contenteditable="true"]{ 
  outline:1px dashed #cbd5e1; border-radius:4px; padding:2px 4px; cursor:text;
}
.category-horizontal .category-actions-inline{
  display:flex; gap:4px; margin-left:4px;
}

.app{
  display:grid;
  grid-template-columns: 280px 320px 1fr 360px;
  gap:12px;
  padding:12px;
  height: calc(100vh - var(--header-height) - var(--categories-bar-height));
  transition: grid-template-columns 0.3s ease;
}

.panel{
  background: var(--panel);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  display:flex; flex-direction:column;
  min-height:0;
}

/* Projects */
.projects h2 { padding:12px; margin:0; border-bottom:1px solid #e2e8f0; display:flex; justify-content:space-between; align-items:center; }
.project-controls{ display:flex; gap:8px; padding:8px 12px; border-bottom:1px solid #e2e8f0; }
.project-controls input{ flex:1; border:1px solid #e2e8f0; border-radius:8px; padding:6px 10px; outline:none; }
.project-controls input:focus{ border-color:var(--accent); }
.project-list{
  overflow:auto; padding:8px 12px; display:flex; flex-direction:column; gap:6px;
  flex:1;
}
.project-item{
  background:#f8fafc; border:1px solid #e2e8f0; border-radius:8px; padding:10px 12px;
  display:flex; justify-content:space-between; align-items:center; gap:8px;
  cursor:pointer; transition: all 0.15s ease;
  box-sizing: border-box;
}
.project-item:hover{ background:#f1f5f9; border-color:#cbd5e1; }
.project-item.active{ background:#eef2ff; border-color:var(--accent); border-width:2px; }
.project-item .name{ flex:1; font-size:14px; font-weight:500; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.project-item button.delete-project{ 
  padding:4px 8px; font-size:11px; opacity:0; transition: opacity 0.15s ease;
  background:#fee; border-color:#fcc; color:#c00;
}
.project-item:hover button.delete-project{ opacity:1; }
.project-list-empty{ 
  padding:20px; text-align:center; color:var(--muted); font-size:13px; 
}

/* Inbox */
.inbox h2 { padding:12px; margin:0; border-bottom:1px solid #e2e8f0; display:flex; justify-content:space-between; align-items:center; }
#chunk-input{
  width:100%; height:140px; border:none; border-bottom:1px solid #e2e8f0; padding:12px; resize:vertical; outline:none;
}
.chunker-controls{ display:flex; gap:8px; padding:8px 12px; border-bottom:1px solid #e2e8f0; }
.chunker-controls button{ flex:1; }
.chunk-list{
  overflow:auto; padding:8px 12px; display:flex; flex-direction:column; gap:8px;
}
.chunk{
  background:#f1f5f9; border:1px solid #e2e8f0; border-radius:10px; padding:8px;
  display:grid; grid-template-columns: 1fr auto; gap:6px; cursor:grab;
}
.chunk:active{ cursor:grabbing; }
.chunk .text[contenteditable="true"]{ outline:1px dashed #cbd5e1; background:#fff; border-radius:6px; padding:4px; }
.chunk .row-actions{ display:flex; gap:6px; align-items:center; }
.chunk .tag{ font-size:11px; color:#475569; }
button.small{ padding:4px 8px; font-size:12px; }

/* Rings */
.rings{ position:relative; }
.rings-toolbar{ padding:6px 10px; border-bottom:1px solid #e2e8f0; color:var(--muted); font-size:12px; }
.rings-stage{ position:relative; flex:1; min-height:0; }
#ring-svg{
  width:100%; height:100%; background: #fff;
  border-bottom-left-radius: var(--radius);
  border-bottom-right-radius: var(--radius);
  outline:none;
}
#pan-surface{ cursor: grab; }
#pan-surface:active{ cursor: grabbing; }

.segment{
  stroke:#fff; stroke-width:2;
  filter: none;
  transform-origin: 0 0;
  transition: transform .2s ease-out, stroke-width .2s ease-out;
}
.segment.hover{
  stroke-width:3;
  filter:url(#dropGlow);
}
.segment.drop-target{
  stroke:#111827; stroke-dasharray:6 4; stroke-width:3;
  transform: scale(1.08);
  transform-origin: 0 0;
}
.segment.dragging{ opacity:.65; }

.center-dot{
  fill: #334155; opacity:.2;
}

.tooltip{
  position:absolute;
  background:#111827; color:#fff; padding:4px 8px; font-size:12px;
  border-radius:8px; pointer-events:none; opacity:0; transform: translate(-50%, -120%);
  white-space: normal;
  max-width: 100px;
  word-wrap: break-word;
  transition: opacity .08s ease;
  box-shadow: 0 6px 20px rgba(0,0,0,.15);
}

/* Right panel */
.right{ display:flex; flex-direction:column; gap:12px; padding:12px; }
.tree-section{
  background:#fff; border:1px solid #e2e8f0; border-radius:12px; padding:10px; flex:1;
}
.tree-section h2 { margin:0 0 8px 0; display:flex; justify-content:space-between; align-items:center; }
.focus-path{ font-size:12px; color:var(--muted); margin-bottom:6px; }

/* 3-row tree aligned as two-column grid: label + list */
.tree-rows{ display:flex; flex-direction:column; gap:10px; }
.tree-row{
  display:grid;
  grid-template-columns: 88px 1fr;
  align-items:start;
  column-gap:8px;
}
.row-title{ font-size:12px; color:var(--muted); margin:0; padding-top:6px; }

.tree-list{
  min-height:42px; background:#f8fafc; border:1px dashed #e2e8f0; padding:6px; border-radius:8px;
  display:flex; flex-wrap:wrap; gap:6px;
}
.placeholder{
  font-size:12px; color:var(--muted-2); padding:4px 6px;
}
.tree-item{
  display:inline-flex; align-items:center; gap:6px;
  background:#fff; border:1px solid #e2e8f0; border-radius:8px; padding:4px 8px; cursor:grab;
}
.tree-item:active{ cursor:grabbing; }
.tree-item .label[contenteditable="true"]{ outline:1px dashed #cbd5e1; border-radius:4px; padding:2px 4px; }
.badge{ font-size:11px; padding:2px 6px; border-radius:999px; border:1px solid #e2e8f0; color:#0f172a; background:#f1f5f9; }
.tree-actions button{ margin-left:4px; }

button{
  appearance:none; border:1px solid #e2e8f0; background:#fff; border-radius:8px; padding:6px 10px; cursor:pointer;
}
button.primary{ background:var(--accent); border-color:var(--accent); color:#fff; }
button.danger{ background:var(--danger); border-color:var(--danger); color:#fff; }

.sep{ display:inline-block; width:1px; height:20px; background:#e2e8f0; margin:0 8px; }
.status-pill{
  display:inline-block; padding:4px 10px; background:#eef2ff; color:#3730a3; border-radius:999px; font-size:12px; border:1px solid #c7d2fe;
}

/* Dialogs */
dialog{
  border:none; border-radius:12px; padding:0; width:min(560px, 92vw);
  box-shadow: var(--shadow);
}
dialog::backdrop{ background: rgba(15,23,42,.4); }
dialog form{ padding:14px; display:flex; flex-direction:column; gap:10px; }
dialog h3{ margin:4px 0 6px 0; }
dialog label{ display:flex; flex-direction:column; gap:4px; font-size:14px; }
dialog textarea{ resize:vertical; }
.two-col{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
.dialog-actions{ display:flex; gap:8px; justify-content:flex-end; padding-top:6px; }
.warning{ color:#b45309; background:#fffbeb; border:1px solid #fcd34d; padding:6px 8px; border-radius:8px; }

/* Toasts */
#toast-container{
  position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%);
  display:flex; flex-direction:column; gap:8px; z-index: 9999;
}
.toast{
  background:#111827; color:#fff; padding:8px 12px; border-radius:10px; box-shadow:0 10px 30px rgba(0,0,0,.25);
  font-size:13px;
}
.toast.ok{ background:#065f46; }
.toast.warn{ background:#92400e; }
.toast.err{ background:#7f1d1d; }

/* Placeholder ring styles */
.segment.placeholder{
  stroke: #94a3b8;
  stroke-width: 3;
  stroke-dasharray: 12 8;
  fill: none;
  opacity: 0.8;
  animation: pulse-placeholder 2s ease-in-out infinite;
  transform-origin: 0 0;
  transition: transform 0.2s ease-out, stroke 0.2s ease-out, stroke-width 0.2s ease-out;
}
.segment.placeholder:hover,
.segment.placeholder.drop-target{
  stroke: #059669;
  stroke-width: 5;
  opacity: 1;
  animation: none;
  transform: scale(1.1);
}

@keyframes pulse-placeholder {
  0%, 100% { opacity: 0.4; }
  50% { opacity: 0.8; }
}

.placeholder-icon {
  animation: pulse-placeholder 2s ease-in-out infinite;
  cursor: pointer;
}
.placeholder-icon:hover {
  animation: none;
  opacity: 1;
}
.segment.placeholder.drop-target + .placeholder-icon,
.placeholder-icon.drop-target {
  transform: scale(1.2);
  transition: transform 0.2s ease-out;
}

/* Panel minimize/expand functionality */
.toggle-panel-btn {
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px 8px;
  font-size: 16px;
  color: var(--muted);
  transition: color 0.15s ease, transform 0.15s ease;
}
.toggle-panel-btn:hover {
  color: var(--ink);
  transform: scale(1.1);
}

.panel.minimized {
  grid-column: span 1;
  min-width: 80px;
  max-width: 80px;
  writing-mode: vertical-rl;
  text-orientation: mixed;
}

.panel.minimized h2 {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  white-space: nowrap;
  padding: 12px 8px;
  cursor: pointer;
  user-select: none;
}

.panel.minimized h2:hover {
  background: #f8fafc;
}

.panel.minimized > *:not(h2) {
  display: none !important;
}

/* Special handling for tree panel which has nested structure */
.panel.right.minimized .tree-section {
  display: flex !important;
  flex-direction: column;
}

.panel.right.minimized .tree-section > *:not(h2) {
  display: none !important;
}

.panel.right.minimized .tree-section h2 {
  writing-mode: vertical-rl;
  text-orientation: mixed;
}

.panel.minimized .toggle-panel-btn {
  writing-mode: horizontal-tb;
  transform: rotate(0deg);
}

/* Adjust grid when panels are minimized */
.app[data-projects-minimized="true"] {
  grid-template-columns: 80px 320px 1fr 360px;
}

.app[data-inbox-minimized="true"] {
  grid-template-columns: 280px 80px 1fr 360px;
}

.app[data-tree-minimized="true"] {
  grid-template-columns: 280px 320px 1fr 80px;
}

.app[data-projects-minimized="true"][data-inbox-minimized="true"] {
  grid-template-columns: 80px 80px 1fr 360px;
}

.app[data-projects-minimized="true"][data-tree-minimized="true"] {
  grid-template-columns: 80px 320px 1fr 80px;
}

.app[data-inbox-minimized="true"][data-tree-minimized="true"] {
  grid-template-columns: 280px 80px 1fr 80px;
}

.app[data-projects-minimized="true"][data-inbox-minimized="true"][data-tree-minimized="true"] {
  grid-template-columns: 80px 80px 1fr 80px;
}
  </style>
</head>
<body>
  <header class="app-header">
    <div class="left-controls">
      <button id="btn-import" title="Import JSON">Import</button>
      <button id="btn-export" title="Export JSON">Export</button>
      <input type="file" id="file-input" accept="application/json" style="display:none" />
    </div>
    <div class="center-controls">
      <button id="btn-home" title="Recenter / Reset Zoom">Home</button>
      <button id="btn-undo" title="Undo (Ctrl+Z)">Undo</button>
      <button id="btn-redo" title="Redo (Ctrl+Y)">Redo</button>
      <span class="sep"></span>
      <span class="zoom-readout">Zoom: <span id="zoom-level">100%</span></span>
    </div>
    <div class="right-controls">
      <span class="status-pill" id="status-pill">Ready</span>
    </div>
  </header>

  <!-- Categories Bar -->
  <section class="categories-bar" id="categories-bar">
    <div class="category-controls">
      <input id="new-cat-name" placeholder="New category name" />
      <input id="new-cat-color" type="color" value="#00aa88" title="Choose category color" />
      <button id="btn-add-category" aria-label="Add new category">Add Category</button>
    </div>
    <div id="category-list" class="category-list-horizontal"></div>
  </section>

  <main class="app">
    <!-- Projects Catalogue -->
    <section class="panel projects" id="projects-panel">
      <h2>
        <span>Projects</span>
        <button class="toggle-panel-btn" id="toggle-projects" title="Minimize panel">◀</button>
      </h2>
      <div class="project-controls">
        <input id="new-project-name" placeholder="New project name" />
        <button id="btn-add-project" title="Create new project">+</button>
      </div>
      <div class="project-list" id="project-list"></div>
    </section>

    <!-- Inbox / Chunker -->
    <section class="panel inbox" id="inbox-panel">
      <h2>
        <span>Chunk Inbox</span>
        <button class="toggle-panel-btn" id="toggle-inbox" title="Minimize panel">◀</button>
      </h2>
      <textarea id="chunk-input" placeholder="Paste longform text here..."></textarea>
      <div class="chunker-controls">
        <button id="btn-smart-chunk">Smart Chunk</button>
        <button id="btn-clear-inbox">Clear Inbox</button>
      </div>
      <div class="chunk-list" id="chunk-list" aria-label="Chunks"></div>
    </section>

    <!-- Center: Rings -->
    <section class="panel rings">
      <div class="rings-toolbar">
        <span>Drag background to pan • Scroll to zoom • Drag nodes to reorder/reparent</span>
      </div>
      <div class="rings-stage" id="rings-stage">
        <svg id="ring-svg" tabindex="0" aria-label="Argument rings" role="application">
          <defs>
            <filter id="dropGlow" x="-50%" y="-50%" width="200%" height="200%">
              <feGaussianBlur in="SourceAlpha" stdDeviation="3" result="blur"/>
              <feMerge>
                <feMergeNode in="blur"/>
                <feMergeNode in="SourceGraphic"/>
              </feMerge>
            </filter>
          </defs>
          <g id="bg">
            <!-- Plain background for infinite panning (no grid/pattern) -->
            <rect id="pan-surface" x="-5000" y="-5000" width="10000" height="10000" fill="#ffffff"></rect>
          </g>
          <g id="viewport" transform="translate(0,0) scale(1)"></g>
        </svg>
        <div id="tooltip" class="tooltip" role="tooltip" aria-hidden="true"></div>
      </div>
    </section>

    <!-- Right: Tree View -->
    <section class="panel right" id="tree-panel">
      <div class="tree-section">
        <h2>
          <span>Tree View</span>
          <button class="toggle-panel-btn" id="toggle-tree" title="Minimize panel">▶</button>
        </h2>
        <div id="focus-path" class="focus-path"></div>
        <div class="tree-rows">
          <div class="tree-row">
            <div class="row-title">Parent</div>
            <div id="tree-parent" class="tree-list" data-row="parent"></div>
          </div>
          <div class="tree-row">
            <div class="row-title">Siblings</div>
            <div id="tree-siblings" class="tree-list" data-row="siblings"></div>
          </div>
          <div class="tree-row">
            <div class="row-title">Children</div>
            <div id="tree-children" class="tree-list" data-row="children"></div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- Modals -->
  <dialog id="edit-argument-dialog">
    <form method="dialog" id="edit-argument-form">
      <h3>Edit Argument</h3>
      <label>Title
        <textarea id="edit-title" rows="3" required></textarea>
      </label>
      <div class="two-col">
        <label>Category
          <select id="edit-category"></select>
        </label>
        <label>Rating
          <input id="edit-rating" type="range" min="1" max="5" step="1" />
          <span id="edit-rating-value">3</span>
        </label>
      </div>
      <div class="dialog-actions">
        <button value="cancel">Cancel</button>
        <button id="btn-delete-node" class="danger" type="button">Delete</button>
        <button id="btn-save-node" class="primary" value="default">Save</button>
      </div>
      <p id="delete-warning" class="warning" hidden>This node has children. Deleting it will remove its entire subtree.</p>
    </form>
  </dialog>

  <dialog id="new-argument-dialog">
    <form method="dialog" id="new-argument-form">
      <h3>New Argument</h3>
      <label>Title
        <textarea id="new-title" rows="3" required></textarea>
      </label>
      <div class="two-col">
        <label>Category
          <select id="new-category"></select>
        </label>
        <label>Rating
          <input id="new-rating" type="range" min="1" max="5" step="1" value="3"/>
          <span id="new-rating-value">3</span>
        </label>
      </div>
      <div class="dialog-actions">
        <button value="cancel">Cancel</button>
        <button class="primary" id="btn-create-node" value="default">Create</button>
      </div>
    </form>
  </dialog>

  <dialog id="link-argument-dialog">
    <form method="dialog" id="link-argument-form">
      <h3>Link Existing Argument</h3>
      <label>Choose node to link
        <select id="link-node-select"></select>
      </label>
      <div class="dialog-actions">
        <button value="cancel">Cancel</button>
        <button class="primary" id="btn-link-node" value="default">Link</button>
      </div>
    </form>
  </dialog>

  <dialog id="chunk-drop-dialog">
    <form method="dialog" id="chunk-drop-form">
      <h3>Add Chunk to Node</h3>
      <p id="chunk-drop-message" style="margin: 8px 0; color: var(--muted); font-size: 14px;">How would you like to add this chunk?</p>
      <div class="dialog-actions">
        <button value="cancel">Cancel</button>
        <button id="btn-chunk-sibling" class="primary" value="sibling">Add as Sibling</button>
        <button id="btn-chunk-combine" class="primary" value="combine">Combine with Existing</button>
      </div>
    </form>
  </dialog>

  <dialog id="node-drop-dialog">
    <form method="dialog" id="node-drop-form">
      <h3>Drop Node</h3>
      <p id="node-drop-message" style="margin: 8px 0; color: var(--muted); font-size: 14px;">What would you like to do with this node?</p>
      <div class="dialog-actions">
        <button value="cancel">Cancel</button>
        <button id="btn-node-reposition" class="primary" value="reposition">Reposition Node</button>
        <button id="btn-node-combine" class="primary" value="combine">Combine Text</button>
      </div>
    </form>
  </dialog>

  <div id="toast-container" aria-live="polite"></div>

  <script>
/* Argument Rings — Visual Reasoning Tool (vanilla JS)
   Updates in this version:
   - Removed grid pattern background; panning uses a plain white infinite rect.
   - Tree view: Parent shows SINGLE parent; Siblings exclude the focused node;
     Children shows only children; clear placeholders when empty.
   - Tree rows aligned via CSS grid (label + list).
*/

(() => {
  // ---------- Utilities ----------
  const $ = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const uid = () => 'id_'+Math.random().toString(36).slice(2,9);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t) => a + (b-a)*t;
  const deg2rad = d => d*Math.PI/180;
  const rad2deg = r => r*180/Math.PI;
  const now = () => Date.now();

  const toastContainer = $("#toast-container");
  const statusPill = $("#status-pill");
  function toast(msg, type="ok", ttl=2200){
    const el = document.createElement("div"); el.className = `toast ${type}`; el.textContent = msg;
    toastContainer.appendChild(el); setTimeout(()=>{ el.remove(); }, ttl);
  }
  function setStatus(msg){ statusPill.textContent = msg; }
  function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }

  // ---------- Persistence + Undo ----------
  const STORAGE_KEY = "argumentRingsState_v1";
  const UNDO_LIMIT = 50;
  const history = { stack: [], cursor: -1, pushing: false };
  function pushHistory(){
    if(history.pushing) return;
    const snapshot = exportState(true);
    history.stack = history.stack.slice(0, history.cursor+1);
    history.stack.push(snapshot);
    if(history.stack.length > UNDO_LIMIT){ history.stack.shift(); }
    history.cursor = history.stack.length - 1;
    saveToStorage();
  }
  function undo(){
    if(history.cursor <= 0) return toast("Nothing to undo","warn");
    history.cursor--;
    const stateObj = history.stack[history.cursor];
    importState(stateObj, {silent:true});
    renderAll();
    saveToStorage();
  }
  function redo(){
    if(history.cursor >= history.stack.length-1) return toast("Nothing to redo","warn");
    history.cursor++;
    const stateObj = history.stack[history.cursor];
    importState(stateObj, {silent:true});
    renderAll();
    saveToStorage();
  }
  $("#btn-undo").addEventListener("click", undo);
  $("#btn-redo").addEventListener("click", redo);
  window.addEventListener("keydown", (e)=>{
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==="z"){ e.preventDefault(); undo(); }
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==="y"){ e.preventDefault(); redo(); }
  });

  function saveToStorage(){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(exportState(true)));
    // Also save current project if one is active
    if(currentProjectId && projects[currentProjectId]){
      saveCurrentProject();
    }
  }
  function loadFromStorage(){
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return null;
    try{ return JSON.parse(raw); } catch{ return null; }
  }

  // ---------- Project Management ----------
  const PROJECTS_KEY = "argumentRingsProjects_v1";
  const CURRENT_PROJECT_KEY = "argumentRingsCurrentProject_v1";
  let projects = {};
  let currentProjectId = null;

  function loadProjects(){
    const raw = localStorage.getItem(PROJECTS_KEY);
    if(!raw) return {};
    try{ return JSON.parse(raw); } catch{ return {}; }
  }

  function saveProjects(){
    localStorage.setItem(PROJECTS_KEY, JSON.stringify(projects));
  }

  function getCurrentProjectId(){
    return localStorage.getItem(CURRENT_PROJECT_KEY);
  }

  function setCurrentProjectId(id){
    currentProjectId = id;
    if(id){
      localStorage.setItem(CURRENT_PROJECT_KEY, id);
    } else {
      localStorage.removeItem(CURRENT_PROJECT_KEY);
    }
  }

  function saveCurrentProject(){
    if(!currentProjectId || !projects[currentProjectId]) return;
    const projectData = exportState(true);
    projects[currentProjectId].data = projectData;
    projects[currentProjectId].lastModified = now();
    saveProjects();
  }

  function loadProject(projectId){
    const project = projects[projectId];
    if(!project) return;
    
    // Save current project before switching
    if(currentProjectId && projects[currentProjectId]){
      saveCurrentProject();
    }
    
    // Load new project
    if(project.data){
      importState(project.data, {silent:true});
    }
    
    setCurrentProjectId(projectId);
    renderAll();
    renderProjects();
    toast(`Loaded project: ${project.name}`, "ok");
  }

  function createProject(name){
    if(!name || !name.trim()) return toast("Project name required","warn");
    
    // Save current project first
    if(currentProjectId && projects[currentProjectId]){
      saveCurrentProject();
    }
    
    const id = uid();
    projects[id] = {
      id,
      name: name.trim(),
      created: now(),
      lastModified: now(),
      data: exportState(true)
    };
    
    setCurrentProjectId(id);
    saveProjects();
    renderProjects();
    toast(`Created project: ${name}`, "ok");
  }

  function deleteProject(projectId){
    if(!projects[projectId]) return;
    const projectName = projects[projectId].name;
    
    if(!confirm(`Delete project "${projectName}"? This cannot be undone.`)) return;
    
    delete projects[projectId];
    
    // If deleting current project, clear current project ID
    if(currentProjectId === projectId){
      setCurrentProjectId(null);
    }
    
    saveProjects();
    renderProjects();
    toast(`Deleted project: ${projectName}`, "ok");
  }

  function renderProjects(){
    const projectList = $("#project-list");
    projectList.innerHTML = "";
    
    const projectIds = Object.keys(projects);
    if(projectIds.length === 0){
      projectList.innerHTML = '<div class="project-list-empty">No projects yet.<br>Create one above!</div>';
      return;
    }
    
    // Sort by last modified (most recent first)
    projectIds.sort((a,b) => projects[b].lastModified - projects[a].lastModified);
    
    projectIds.forEach(id => {
      const project = projects[id];
      const item = document.createElement("div");
      item.className = "project-item";
      if(id === currentProjectId) item.classList.add("active");
      
      const nameSpan = document.createElement("span");
      nameSpan.className = "name";
      nameSpan.textContent = project.name;
      nameSpan.title = project.name;
      
      const deleteBtn = document.createElement("button");
      deleteBtn.className = "delete-project";
      deleteBtn.textContent = "Delete";
      deleteBtn.onclick = (e) => {
        e.stopPropagation();
        deleteProject(id);
      };
      
      item.appendChild(nameSpan);
      item.appendChild(deleteBtn);
      
      item.onclick = () => loadProject(id);
      
      projectList.appendChild(item);
    });
  }

  // Project UI handlers
  $("#btn-add-project").addEventListener("click", ()=>{
    const input = $("#new-project-name");
    const name = input.value.trim();
    if(name){
      createProject(name);
      input.value = "";
    }
  });

  $("#new-project-name").addEventListener("keypress", (e)=>{
    if(e.key === "Enter"){
      e.preventDefault();
      $("#btn-add-project").click();
    }
  });

  // ---------- Data Model ----------
  const state = {
    categories: {},
    catOrder: [],
    rootId: null,
    nodes: {},
    focusId: null,
    inbox: [],
    consumedChunkIds: {},
    view: { panX: 0, panY: 0, zoom: 1 },
  };

  function ensureDefaults(){
    if(Object.keys(state.categories).length===0){
      const defaults = [
        ["Pro", "#22c55e"],
        ["Con", "#ef4444"],
        ["Fallacy", "#f59e0b"],
        ["Deductive", "#3b82f6"],
        ["Inductive", "#8b5cf6"],
        ["Abductive", "#14b8a6"],
      ];
      defaults.forEach(([name, color])=>{
        const id = uid();
        state.categories[id] = {id, name, colorHex: color};
        state.catOrder.push(id);
      });
    }
    if(!state.rootId){
      const root = { id: uid(), title: "Root", categoryId: state.catOrder[0], rating: 3, children: [], parentId: null };
      state.rootId = root.id;
      state.nodes[root.id] = root;
    }
    if(!state.focusId){
      state.focusId = state.rootId;
    }
  }

  // ---------- Category helpers ----------
  function hexToHsl(hex){
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if(!m) return {h:0,s:0,l:.5};
    let r = parseInt(m[1],16)/255, g=parseInt(m[2],16)/255, b=parseInt(m[3],16)/255;
    const max=Math.max(r,g,b), min=Math.min(r,g,b);
    let h,s,l=(max+min)/2;
    if(max===min){ h=s=0; }
    else{
      const d=max-min;
      s = l>0.5? d/(2-max-min) : d/(max+min);
      switch(max){
        case r: h=(g-b)/d + (g<b?6:0); break;
        case g: h=(b-r)/d + 2; break;
        case b: h=(r-g)/d + 4; break;
      }
      h*=60;
    }
    return {h,s,l};
  }
  function colorFor(node){
    const cat = state.categories[node.categoryId] || Object.values(state.categories)[0];
    const {h,s,l} = hexToHsl(cat.colorHex);
    const sat = Math.max(0, Math.min(1, s * (0.35 + 0.13*node.rating)));
    const light = Math.max(0.25, Math.min(0.8, 0.62 - 0.04*node.rating));
    return `hsl(${Math.round(h)}deg ${Math.round(sat*100)}% ${Math.round(light*100)}%)`;
  }

  // ---------- Layout ----------
  const ringWidth = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--ring-width")) || 64;
  const ringGap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--ring-gap")) || 2.5;

  function countDescendants(nodeId){
    const node = state.nodes[nodeId];
    if(!node || !node.children || node.children.length === 0) return 0;
    let count = node.children.length;
    for(const childId of node.children){
      count += countDescendants(childId);
    }
    return count;
  }

  function buildHierarchy(rootId){
    const nodes = state.nodes;
    const annotated = {};
    function assignAngles(nodeId, a0, a1, depth){
      const node = nodes[nodeId];
      annotated[nodeId] = { a0, a1, depth };
      const kids = node.children || [];
      const span = a1 - a0;
      const n = kids.length;
      
      if(n === 0) return;
      
      // Calculate progeny (descendants) count for each child
      // Formula: 1 (the child itself) + count of all its descendants
      const progenyCount = kids.map(kId => 1 + countDescendants(kId));
      const totalProgeny = progenyCount.reduce((sum, count) => sum + count, 0);
      
      // Allocate space proportionally based on progeny count
      let currentAngle = a0;
      for(let i=0; i<n; i++){
        const kId = kids[i];
        const proportion = progenyCount[i] / totalProgeny;
        const k0 = currentAngle;
        const k1 = currentAngle + span * proportion;
        assignAngles(kId, k0, k1, depth+1);
        currentAngle = k1;
      }
    }
    assignAngles(rootId, 0, Math.PI*2, 0);
    return annotated;
  }

  function maxDepthFrom(id){
    let md = 0;
    (function dfs(n, d){
      md = Math.max(md, d);
      const node = state.nodes[n];
      (node.children||[]).forEach(c => dfs(c, d+1));
    })(id, 0);
    return md;
  }

  function annularPath(cx, cy, rInner, rOuter, a0, a1, gapAngle=deg2rad(1.8)){
    const pad = gapAngle/2;
    const aa0 = a0 + pad;
    const aa1 = a1 - pad;
    const largeArc = (aa1 - aa0) % (2*Math.PI) > Math.PI ? 1 : 0;

    const p0 = { x: cx + rOuter*Math.cos(aa0), y: cy + rOuter*Math.sin(aa0) };
    const p1 = { x: cx + rOuter*Math.cos(aa1), y: cy + rOuter*Math.sin(aa1) };
    const p2 = { x: cx + rInner*Math.cos(aa1), y: cy + rInner*Math.sin(aa1) };
    const p3 = { x: cx + rInner*Math.cos(aa0), y: cy + rInner*Math.sin(aa0) };

    return [
      `M ${p0.x} ${p0.y}`,
      `A ${rOuter} ${rOuter} 0 ${largeArc} 1 ${p1.x} ${p1.y}`,
      `L ${p2.x} ${p2.y}`,
      `A ${rInner} ${rInner} 0 ${largeArc} 0 ${p3.x} ${p3.y}`,
      `Z`
    ].join(' ');
  }

  // ---------- SVG / Pan & Zoom ----------
  const svg = $("#ring-svg");
  const viewport = $("#viewport");
  const panSurface = $("#pan-surface");
  const tooltip = $("#tooltip");
  const zoomReadout = $("#zoom-level");
  let view = state.view;

  function applyView(){
    viewport.setAttribute("transform", `translate(${view.panX},${view.panY}) scale(${view.zoom})`);
    zoomReadout.textContent = Math.round(view.zoom*100)+'%';
  }
  function homeView(){
    view.panX = svg.clientWidth/2;
    view.panY = svg.clientHeight/2;
    view.zoom = 1;
    applyView();
  }
  $("#btn-home").addEventListener("click", ()=>{ homeView(); pushHistory(); });

  function svgPoint(evt){
    const pt = svg.createSVGPoint();
    pt.x = evt.clientX; pt.y = evt.clientY;
    const inv = viewport.getScreenCTM().inverse();
    return pt.matrixTransform(inv);
  }

  // Pan
  let panning=false, panStart={x:0,y:0}, viewStart={x:0,y:0};
  panSurface.addEventListener("pointerdown", (e)=>{
    panning = true; panStart = {x:e.clientX, y:e.clientY}; viewStart={x:view.panX, y:view.panY};
    panSurface.setPointerCapture(e.pointerId);
  });
  panSurface.addEventListener("pointermove", (e)=>{
    if(!panning) return;
    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;
    view.panX = viewStart.x + dx;
    view.panY = viewStart.y + dy;
    applyView();
  });
  panSurface.addEventListener("pointerup", (e)=>{ panning=false; panSurface.releasePointerCapture(e.pointerId); pushHistory(); });

  // Zoom (wheel)
  svg.addEventListener("wheel", (e)=>{
    e.preventDefault();
    const scaleFactor = Math.pow(1.0018, -e.deltaY);
    const prev = view.zoom;
    const next = Math.max(0.2, Math.min(3.5, prev * scaleFactor));

    const ptBefore = svgPoint(e);
    view.zoom = next;
    applyView();
    const ptAfter = svgPoint(e);
    view.panX += (ptAfter.x - ptBefore.x) * next;
    view.panY += (ptAfter.y - ptBefore.y) * next;
    applyView();
  }, {passive:false});

  // ---------- Rendering ----------
  function renderRings(){
    viewport.innerHTML = "";

    const layout = buildHierarchy(state.rootId);
    const cx = 0, cy = 0;
    const r0 = ringWidth * 0.5;
    const centerDot = document.createElementNS("http://www.w3.org/2000/svg","circle");
    centerDot.setAttribute("class","center-dot");
    centerDot.setAttribute("cx", cx);
    centerDot.setAttribute("cy", cy);
    centerDot.setAttribute("r", r0*0.7);
    viewport.appendChild(centerDot);

    // Group segments by depth for proper z-ordering
    const depthGroups = new Map();
    const layers = new Map();
    const placeholders = [];
    
    // First pass: collect all segments and group by depth
    const segmentsByDepth = new Map();
    Object.entries(layout).forEach(([id, l])=>{
      const node = state.nodes[id];
      const depth = l.depth;
      
      // Collect actual segments for non-root nodes
      if(id !== state.rootId) {
        if(!segmentsByDepth.has(depth)) segmentsByDepth.set(depth, []);
        segmentsByDepth.get(depth).push({ id, node, layout: l, depth });
      }
    });
    
    // Second pass: render segments in depth order (inner to outer)
    const sortedDepths = Array.from(segmentsByDepth.keys()).sort((a, b) => a - b);
    sortedDepths.forEach(depth => {
      // Create a group element for this depth level
      const depthGroup = document.createElementNS("http://www.w3.org/2000/svg","g");
      depthGroup.setAttribute("class", `depth-group depth-${depth}`);
      depthGroup.setAttribute("data-depth", depth);
      viewport.appendChild(depthGroup);
      depthGroups.set(depth, depthGroup);
      
      // Render all segments at this depth
      const segments = segmentsByDepth.get(depth);
      segments.forEach(({id, node, layout: l}) => {
        const rInner = r0 + (depth-1)*(ringWidth + ringGap);
        const rOuter = rInner + ringWidth;
        const pathEl = document.createElementNS("http://www.w3.org/2000/svg","path");
        pathEl.setAttribute("class", "segment");
        pathEl.setAttribute("fill", colorFor(node));
        pathEl.setAttribute("data-id", id);
        pathEl.setAttribute("data-depth", depth);
        pathEl.setAttribute("d", annularPath(cx, cy, rInner, rOuter, l.a0, l.a1));
        addSegmentListeners(pathEl);
        depthGroup.appendChild(pathEl);

        if(!layers.has(depth)) layers.set(depth, []);
        layers.get(depth).push({ id, depth, a0:l.a0, a1:l.a1, rInner, rOuter, el: pathEl });
      });
    });
    
    // Third pass: add placeholders
    Object.entries(layout).forEach(([id, l])=>{
      const node = state.nodes[id];
      const depth = l.depth;
      
      // Add placeholder ring for nodes without children (including root)
      if(!node.children || node.children.length === 0){
        const childDepth = depth + 1;
        const childRInner = r0 + (childDepth-1)*(ringWidth + ringGap);
        const childROuter = childRInner + ringWidth;
        
        // Reusable click handler for opening new argument dialog
        const handlePlaceholderClick = (e) => {
          e.stopPropagation();
          openNewModal({mode: "child", refId: id});
        };
        
        const placeholderEl = document.createElementNS("http://www.w3.org/2000/svg","path");
        placeholderEl.setAttribute("class", "segment placeholder");
        placeholderEl.setAttribute("d", annularPath(cx, cy, childRInner, childROuter, l.a0, l.a1));
        placeholderEl._parentId = id;
        placeholderEl.style.cursor = "pointer";
        placeholderEl.addEventListener("click", handlePlaceholderClick);
        
        // Append to appropriate depth group or viewport
        if(depthGroups.has(childDepth)) {
          depthGroups.get(childDepth).appendChild(placeholderEl);
        } else {
          viewport.appendChild(placeholderEl);
        }
        placeholders.push(placeholderEl);
        
        // Add a plus icon in the center of the placeholder ring
        const midAngle = (l.a0 + l.a1) / 2;
        const midRadius = (childRInner + childROuter) / 2;
        const iconX = cx + midRadius * Math.cos(midAngle);
        const iconY = cy + midRadius * Math.sin(midAngle);
        
        const plusGroup = document.createElementNS("http://www.w3.org/2000/svg","g");
        plusGroup.setAttribute("class", "placeholder-icon");
        plusGroup.setAttribute("transform", `translate(${iconX},${iconY})`);
        plusGroup.style.cursor = "pointer";
        plusGroup.addEventListener("click", handlePlaceholderClick);
        
        // Plus sign background circle
        const bgCircle = document.createElementNS("http://www.w3.org/2000/svg","circle");
        bgCircle.setAttribute("r", "12");
        bgCircle.setAttribute("fill", "#ffffff");
        bgCircle.setAttribute("stroke", "#94a3b8");
        bgCircle.setAttribute("stroke-width", "2");
        bgCircle.setAttribute("opacity", "0.9");
        plusGroup.appendChild(bgCircle);
        
        // Plus sign lines
        const vLine = document.createElementNS("http://www.w3.org/2000/svg","line");
        vLine.setAttribute("x1", "0"); vLine.setAttribute("y1", "-6");
        vLine.setAttribute("x2", "0"); vLine.setAttribute("y2", "6");
        vLine.setAttribute("stroke", "#6b7280"); vLine.setAttribute("stroke-width", "2");
        plusGroup.appendChild(vLine);
        
        const hLine = document.createElementNS("http://www.w3.org/2000/svg","line");
        hLine.setAttribute("x1", "-6"); hLine.setAttribute("y1", "0");
        hLine.setAttribute("x2", "6"); hLine.setAttribute("y2", "0");
        hLine.setAttribute("stroke", "#6b7280"); hLine.setAttribute("stroke-width", "2");
        plusGroup.appendChild(hLine);
        
        viewport.appendChild(plusGroup);
        // Link the icon to the placeholder ring for hover effects
        placeholderEl._plusIcon = plusGroup;
      }
    });

    viewport._layers = layers;
    viewport._placeholders = placeholders;
    viewport._depthGroups = depthGroups;
    
    // Ensure viewport reference is properly accessible for drag-drop handlers
    if (typeof window !== 'undefined') {
      window.viewport = viewport;
    }
  }

  // ---------- Tooltip ----------
  let tooltipActiveId = null;
  let originalDepthGroupParent = null; // Track original position for restoration
  function addSegmentListeners(el){
    el.addEventListener("mouseenter", ()=>{
      const id = el.dataset.id;
      tooltipActiveId = id;
      const node = state.nodes[id];
      tooltip.textContent = displayTitle(node);
      tooltip.style.opacity = "1";
      tooltip.setAttribute("aria-hidden", "false");
      el.classList.add("hover");
      
      // Position tooltip above the center of the element, offset 400px to the left and 300px down
      const rect = el.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      tooltip.style.left = (centerX - 400) + "px";
      tooltip.style.top = (centerY + 300) + "px";
      
      // Bring element to front within its depth group
      const depthGroup = el.parentNode;
      if(depthGroup && depthGroup.classList && depthGroup.classList.contains('depth-group')) {
        depthGroup.appendChild(el);
        
        // Also bring the entire depth group to the front so it appears above children
        // Store the next sibling to restore position later
        originalDepthGroupParent = {
          group: depthGroup,
          nextSibling: depthGroup.nextSibling
        };
        viewport.appendChild(depthGroup);
      }
    });
    el.addEventListener("mouseleave", ()=>{
      tooltipActiveId = null;
      tooltip.style.opacity = "0";
      tooltip.setAttribute("aria-hidden", "true");
      el.classList.remove("hover");
      
      // Restore the depth group to its original position
      if(originalDepthGroupParent && originalDepthGroupParent.group) {
        const group = originalDepthGroupParent.group;
        const nextSib = originalDepthGroupParent.nextSibling;
        if(nextSib && nextSib.parentNode === viewport) {
          viewport.insertBefore(group, nextSib);
        } else {
          // If nextSibling is null or not in viewport, find correct position by depth
          const groupDepth = parseInt(group.getAttribute('data-depth'));
          const allGroups = Array.from(viewport.querySelectorAll('.depth-group'));
          let inserted = false;
          for(const otherGroup of allGroups) {
            const otherDepth = parseInt(otherGroup.getAttribute('data-depth'));
            if(otherDepth > groupDepth) {
              viewport.insertBefore(group, otherGroup);
              inserted = true;
              break;
            }
          }
          if(!inserted) {
            viewport.appendChild(group);
          }
        }
        originalDepthGroupParent = null;
      }
    });
    el.addEventListener("click", ()=>{
      const id = el.dataset.id;
      openEditModal(id);
      focusNode(id);
    });
    el.addEventListener("pointerdown", segmentDragStart);
  }

  // ---------- Segment Drag / Drop ----------
  let dragSeg = null;
  let dragOverTarget = null;
  const DRAG_THRESHOLD = 8; // pixels - minimum distance to register as drag vs click

  function segmentDragStart(e){
    e.stopPropagation();
    const id = e.currentTarget.dataset.id;
    const startX = e.clientX;
    const startY = e.clientY;
    
    // Track initial pointer position but don't start dragging yet
    dragSeg = { 
      id, 
      pointerId: e.pointerId, 
      startX, 
      startY, 
      isDragging: false,
      element: e.currentTarget
    };
    
    svg.setPointerCapture(e.pointerId);
    svg.addEventListener("pointermove", segmentDragMove);
    svg.addEventListener("pointerup", segmentDragEnd);
  }
  function segmentDragMove(e){
    if(!dragSeg) return;
    
    // Check if we've moved beyond the drag threshold
    if(!dragSeg.isDragging) {
      const dx = e.clientX - dragSeg.startX;
      const dy = e.clientY - dragSeg.startY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if(distance < DRAG_THRESHOLD) {
        // Not yet dragging - still within click threshold
        return;
      }
      
      // Start actual dragging
      dragSeg.isDragging = true;
      dragSeg.element.classList.add("dragging");
      setStatus("Dragging segment…");
    }
    
    // Continue with drag operation
    const pt = svgPoint(e);
    const target = pickSegmentAt(pt.x, pt.y);
    updateDragVisual(target);
  }
  function segmentDragEnd(e){
    if(!dragSeg) return;
    svg.releasePointerCapture(dragSeg.pointerId);
    
    // Check if this was actually a drag or just a click
    if(!dragSeg.isDragging) {
      // This was a click, not a drag - manually trigger the click handler
      const id = dragSeg.id;
      const element = dragSeg.element;
      svg.removeEventListener("pointermove", segmentDragMove);
      svg.removeEventListener("pointerup", segmentDragEnd);
      dragSeg = null;
      
      // Manually call the click handler logic
      openEditModal(id);
      focusNode(id);
      return;
    }
    
    // This was a drag - process the drop
    const sourceId = dragSeg.id;
    const pt = svgPoint(e);
    const target = pickSegmentAt(pt.x, pt.y);

    $$(".segment.dragging").forEach(el=>el.classList.remove("dragging"));
    if(dragOverTarget){ dragOverTarget.el.classList.remove("drop-target"); dragOverTarget=null; }
    svg.removeEventListener("pointermove", segmentDragMove);
    svg.removeEventListener("pointerup", segmentDragEnd);

    if(!target){ setStatus("Ready"); dragSeg = null; return; }

    const src = state.nodes[sourceId];
    const srcDepth = getDepthOf(sourceId);
    const tgtDepth = target.depth;
    const tgtNode = state.nodes[target.id];

    if(target.id === sourceId || isDescendant(sourceId, target.id)){
      toast("Invalid drop: cannot drop onto self/descendant","warn"); setStatus("Ready"); dragSeg = null; return;
    }
    
    // Show dialog to ask user what to do - reposition or combine text
    const srcTitle = src.title.slice(0, 50) + (src.title.length > 50 ? "..." : "");
    const tgtTitle = tgtNode.title.slice(0, 50) + (tgtNode.title.length > 50 ? "..." : "");
    $("#node-drop-message").textContent = `Drop "${srcTitle}" onto "${tgtTitle}". What would you like to do?`;
    
    // Store context for the dialog handlers
    const dropContext = {
      sourceId,
      targetId: target.id,
      srcDepth,
      tgtDepth,
    };
    
    // Set up dialog button handlers
    $("#btn-node-reposition").onclick = (evt) => {
      evt.preventDefault();
      nodeDropDialog.close();
      
      // Execute the reposition logic based on depth
      if(dropContext.tgtDepth === dropContext.srcDepth){
        // Same ring - reorder as siblings
        reorderIntoSiblingPosition(dropContext.sourceId, dropContext.targetId);
        toast("Reordered","ok");
      } else if (dropContext.tgtDepth === dropContext.srcDepth - 1) {
        // One ring inward - move as child
        moveAsChild(dropContext.sourceId, dropContext.targetId);
        toast("Moved as child","ok");
      } else {
        // Different generation move - show warning and get user confirmation
        const srcNode = state.nodes[dropContext.sourceId];
        const tgtNode = state.nodes[dropContext.targetId];
        const generationDiff = Math.abs(dropContext.tgtDepth - dropContext.srcDepth);
        const direction = dropContext.tgtDepth < dropContext.srcDepth ? "inward" : "outward";
        const relationshipChange = dropContext.tgtDepth < dropContext.srcDepth ? 
          `"${srcNode.title.slice(0,40)}..." will become a child of "${tgtNode.title.slice(0,40)}..."` :
          `"${srcNode.title.slice(0,40)}..." will become a sibling of "${tgtNode.title.slice(0,40)}..."`;
        
        const shouldProceed = confirm(
          `⚠️ Cross-Generation Move Warning\n\n` +
          `You are moving a node ${generationDiff} generation${generationDiff > 1 ? 's' : ''} ${direction}.\n\n` +
          `${relationshipChange}\n\n` +
          `This will reorganize the tree structure. Do you want to proceed?`
        );
        
        if(shouldProceed) {
          if(dropContext.tgtDepth < dropContext.srcDepth) {
            // Move inward (become child)
            moveAsChild(dropContext.sourceId, dropContext.targetId);
            toast("Moved as child across generations","ok");
          } else {
            // Move outward (become sibling)
            reorderIntoSiblingPosition(dropContext.sourceId, dropContext.targetId);
            toast("Moved as sibling across generations","ok");
          }
        } else {
          toast("Cross-generation move cancelled","info");
          setStatus("Ready");
          return;
        }
      }
      setStatus("Ready");
      pushHistory(); renderAll();
    };
    
    $("#btn-node-combine").onclick = (evt) => {
      evt.preventDefault();
      nodeDropDialog.close();
      
      // Combine the text from source node into target node
      const srcNode = state.nodes[dropContext.sourceId];
      const tgtNode = state.nodes[dropContext.targetId];
      const existingTitle = tgtNode.title || "";
      const sourceTitle = srcNode.title || "";
      
      // Combine with a space separator
      tgtNode.title = (existingTitle + " " + sourceTitle).trim();
      
      // Store parent ID before deleting the node
      const srcParentId = srcNode.parentId;
      
      // Delete the source node after combining
      deleteSubtree(dropContext.sourceId);
      const srcParent = state.nodes[srcParentId];
      if(srcParent){ srcParent.children = srcParent.children.filter(x => x !== dropContext.sourceId); }
      if(state.focusId === dropContext.sourceId) state.focusId = state.rootId;
      
      toast("Combined text and removed source node","ok");
      setStatus("Ready");
      pushHistory(); renderAll();
    };
    
    // Show the dialog
    if(typeof nodeDropDialog.showModal === "function"){ 
      nodeDropDialog.showModal(); 
    } else { 
      alert("Your browser does not support <dialog>."); 
    }
    
    setStatus("Ready");
    dragSeg = null;
  }
  function updateDragVisual(target){
    if(dragOverTarget && (!target || dragOverTarget.id !== target.id)){
      dragOverTarget.el.classList.remove("drop-target");
      
      // Restore the depth group to its original position
      if(dragOverTarget._savedPosition && dragOverTarget._savedPosition.group) {
        const group = dragOverTarget._savedPosition.group;
        const nextSib = dragOverTarget._savedPosition.nextSibling;
        if(nextSib && nextSib.parentNode === viewport) {
          viewport.insertBefore(group, nextSib);
        } else {
          // Find correct position by depth
          const groupDepth = parseInt(group.getAttribute('data-depth'));
          const allGroups = Array.from(viewport.querySelectorAll('.depth-group'));
          let inserted = false;
          for(const otherGroup of allGroups) {
            const otherDepth = parseInt(otherGroup.getAttribute('data-depth'));
            if(otherDepth > groupDepth) {
              viewport.insertBefore(group, otherGroup);
              inserted = true;
              break;
            }
          }
          if(!inserted) {
            viewport.appendChild(group);
          }
        }
        dragOverTarget._savedPosition = null;
      }
      
      dragOverTarget = null;
    }
    if(target){
      target.el.classList.add("drop-target");
      
      // Bring element to front within its depth group
      const depthGroup = target.el.parentNode;
      if(depthGroup && depthGroup.classList && depthGroup.classList.contains('depth-group')) {
        depthGroup.appendChild(target.el);
        
        // Also bring the entire depth group to the front
        target._savedPosition = {
          group: depthGroup,
          nextSibling: depthGroup.nextSibling
        };
        viewport.appendChild(depthGroup);
      }
      
      dragOverTarget = target;
    }
  }

  function pickSegmentAt(x, y){
    const depthInfo = viewport._layers;
    if(!depthInfo) return null;
    const r = Math.hypot(x, y);
    const angle = Math.atan2(y, x);
    const normAngle = angle>=0 ? angle : (2*Math.PI + angle);

    const dApprox = Math.round((r - (ringWidth*0.5)) / (ringWidth + ringGap)) + 1;
    const candidates = [dApprox-1, dApprox, dApprox+1].filter(d => depthInfo.has(d));
    for(const d of candidates){
      const arr = depthInfo.get(d);
      for(const it of arr){
        if(r >= it.rInner && r <= it.rInner + ringWidth + 0.5){
          if(normAngle >= it.a0 && normAngle <= it.a1){
            return it;
          }
        }
      }
    }
    return null;
  }

  function getDepthOf(nodeId){
    let d = 0, cur = nodeId;
    while(true){
      const n = state.nodes[cur];
      if(!n || n.parentId==null) break;
      d++; cur = n.parentId;
    }
    return d;
  }
  function isDescendant(nodeId, maybeAncestor){
    let cur = state.nodes[nodeId];
    while(cur && cur.parentId){
      if(cur.parentId === maybeAncestor) return true;
      cur = state.nodes[cur.parentId];
    }
    return false;
  }
  function reorderIntoSiblingPosition(srcId, targetSiblingId){
    const src = state.nodes[srcId];
    const target = state.nodes[targetSiblingId];
    const parentId = target.parentId;
    if(src.parentId){
      const arr = state.nodes[src.parentId].children;
      const i = arr.indexOf(srcId);
      if(i>=0) arr.splice(i,1);
    }
    const list = state.nodes[parentId].children;
    const idx = list.indexOf(targetSiblingId);
    const insertAt = idx>=0 ? idx+1 : list.length;
    if(!list.includes(srcId)) list.splice(insertAt, 0, srcId);
    src.parentId = parentId;
  }
  function moveAsChild(srcId, newParentId){
    const src = state.nodes[srcId];
    if(src.parentId){
      const arr = state.nodes[src.parentId].children;
      const i = arr.indexOf(srcId);
      if(i>=0) arr.splice(i,1);
    }
    const np = state.nodes[newParentId];
    if(!np.children) np.children = [];
    if(!np.children.includes(srcId)) np.children.push(srcId);
    src.parentId = newParentId;
  }

  function reorganizeTreeForCircularMove(sourceId, targetParentId){
    // This handles the case where a node is moved to be a child of its own descendant
    // We need to "bump up" the tree by making the descendant the new parent
    
    const sourceNode = state.nodes[sourceId];
    const targetParent = state.nodes[targetParentId];
    
    // Step 1: Find the path from targetParent back to sourceId
    const pathToSource = [];
    let current = targetParent;
    while(current && current.id !== sourceId) {
      pathToSource.push(current.id);
      current = current.parentId ? state.nodes[current.parentId] : null;
    }
    
    // Step 2: Reverse the parent-child relationships along this path
    // The targetParent becomes the new root of this subtree
    const originalSourceParent = sourceNode.parentId;
    
    // Remove sourceNode from its current parent
    if(originalSourceParent) {
      const sourceParentChildren = state.nodes[originalSourceParent].children;
      const idx = sourceParentChildren.indexOf(sourceId);
      if(idx >= 0) sourceParentChildren.splice(idx, 1);
    }
    
    // Reverse the relationships along the path
    let prevParent = originalSourceParent;
    for(let i = pathToSource.length - 1; i >= 0; i--) {
      const nodeId = pathToSource[i];
      const node = state.nodes[nodeId];
      const oldParent = node.parentId;
      
      // Remove this node from its old parent's children
      if(oldParent) {
        const oldParentChildren = state.nodes[oldParent].children;
        const idx = oldParentChildren.indexOf(nodeId);
        if(idx >= 0) oldParentChildren.splice(idx, 1);
      }
      
      // Set this node's new parent
      node.parentId = prevParent;
      
      // Add this node to its new parent's children (if parent exists)
      if(prevParent) {
        const newParentNode = state.nodes[prevParent];
        if(!newParentNode.children) newParentNode.children = [];
        if(!newParentNode.children.includes(nodeId)) {
          newParentNode.children.push(nodeId);
        }
      }
      
      prevParent = nodeId;
    }
    
    // Step 3: Finally, make sourceNode a child of targetParent
    sourceNode.parentId = targetParentId;
    if(!targetParent.children) targetParent.children = [];
    if(!targetParent.children.includes(sourceId)) {
      targetParent.children.push(sourceId);
    }
  }

  // ---------- Tree View (3 rows) ----------
  const treeParent = $("#tree-parent");
  const treeSiblings = $("#tree-siblings");
  const treeChildren = $("#tree-children");
  const focusPath = $("#focus-path");

  function displayTitle(node){
    if(node.linkTo && state.nodes[node.linkTo]){
      return `↪ ${state.nodes[node.linkTo].title}`;
    }
    return node.title || "(untitled)";
  }

  function placeholder(text){
    const el = document.createElement("div");
    el.className = "placeholder";
    el.textContent = text;
    return el;
  }

  function focusNode(id){
    if(!state.nodes[id]) return;
    state.focusId = id;
    renderTree();
    renderRings();
    saveToStorage();
  }

  function nodeBadge(node){
    const cat = state.categories[node.categoryId] || {};
    const span = document.createElement("span");
    span.className = "badge";
    span.textContent = `${cat.name || "Cat"} · ${node.rating}`;
    return span;
  }

  function buildTreeItem(node){
    const el = document.createElement("div");
    el.className = "tree-item";
    el.draggable = true;
    el.dataset.id = node.id;

    const label = document.createElement("span");
    label.className = "label";
    label.contentEditable = "true";
    label.textContent = displayTitle(node);
    label.addEventListener("blur", ()=>{
      const s = label.textContent.trim();
      if(s!==displayTitle(node)){
        if(node.linkTo && state.nodes[node.linkTo]){
          state.nodes[node.linkTo].title = s;
        } else {
          node.title = s;
        }
        pushHistory(); renderAll();
      }
    });
    label.addEventListener("click", ()=> focusNode(node.id));

    const badge = nodeBadge(node);

    const actions = document.createElement("span");
    actions.className = "tree-actions";
    actions.append(
      button("⋯", "small", ()=> openEditModal(node.id)),
      button("+sib","small", ()=> openNewModal({mode:"sibling", refId:node.id})),
      button("+child","small", ()=> openNewModal({mode:"child", refId:node.id})),
      button("Dup","small", ()=> duplicateNode(node.id)),
      button("Link","small", ()=> openLinkModal(node.id)),
      button("Unlink","small", ()=> unlinkNode(node.id)),
      button("Del","small danger", ()=> deleteNodeWithConfirm(node.id))
    );

    el.append(label, badge, actions);

    el.addEventListener("dragstart", (e)=>{
      e.dataTransfer.setData("application/x-node-id", node.id);
      e.dataTransfer.effectAllowed = "move";
    });
    el.addEventListener("dragover", (e)=>{ e.preventDefault(); el.classList.add("hover"); });
    el.addEventListener("dragleave", ()=> el.classList.remove("hover"));
    el.addEventListener("drop", (e)=>{
      e.preventDefault();
      el.classList.remove("hover");
      const srcId = e.dataTransfer.getData("application/x-node-id");
      if(!srcId) return;
      if(srcId === node.id) return toast("Cannot drop a node onto itself","warn");
      
      if(isDescendant(node.id, srcId)) {
        // Ancestor trying to become sibling of descendant - show warning
        const srcNode = state.nodes[srcId];
        const shouldProceed = confirm(
          `⚠️ Cross-Generation Sibling Warning\n\n` +
          `You are trying to move "${srcNode.title.slice(0,40)}..." to be a sibling of its descendant "${node.title.slice(0,40)}...".\n\n` +
          `This will create a complex tree reorganization. Do you want to proceed?`
        );
        
        if(!shouldProceed) {
          toast("Move cancelled by user","info");
          return;
        }
        
        toast("Complex cross-generation move completed","ok");
      }
      reorderIntoSiblingPosition(srcId, node.id);
      pushHistory(); renderAll(); toast("Reordered","ok");
    });

    return el;
  }

  function renderTree(){
    // Ensure focusId points to a valid node, otherwise reset to root
    if(!state.nodes[state.focusId]){
      state.focusId = state.rootId;
    }
    const f = state.nodes[state.focusId];

    // Focus path - show only the focused node's title
    focusPath.textContent = f.title || "Root";

    // Parent
    treeParent.innerHTML="";
    const parent = state.nodes[f.parentId];
    if(parent && parent.id !== state.rootId){
      treeParent.appendChild(buildTreeItem(parent));
    } else {
      treeParent.appendChild(placeholder("(none)"));
    }

    // Siblings (exclude focused)
    treeSiblings.innerHTML="";
    if(parent){
      const siblings = (parent.children||[]).filter(sid=> sid!==f.id);
      if(siblings.length){
        siblings.forEach(sid=> treeSiblings.appendChild(buildTreeItem(state.nodes[sid])));
      } else {
        treeSiblings.appendChild(placeholder("(no siblings)"));
      }
    } else {
      treeSiblings.appendChild(placeholder("(no siblings)"));
    }

    // Children
    treeChildren.innerHTML="";
    if(f.children && f.children.length){
      f.children.forEach(cid=> treeChildren.appendChild(buildTreeItem(state.nodes[cid])));
    } else {
      treeChildren.appendChild(placeholder("(no children)"));
    }

    // Drop targets for reparenting
    [treeChildren, treeSiblings, treeParent].forEach(list=>{
      list.addEventListener("dragover", (e)=> e.preventDefault());
      list.addEventListener("drop", (e)=>{
        e.preventDefault();
        const srcId = e.dataTransfer.getData("application/x-node-id");
        if(!srcId) return;

        if(list === treeChildren){
          const srcNode = state.nodes[srcId];
          const focusedNode = state.nodes[state.focusId];
          
          if(isDescendant(state.focusId, srcId)) {
            // Ancestor trying to become child of descendant - show warning
            const shouldReorganize = confirm(
              `⚠️ Circular Relationship Warning\n\n` +
              `You are trying to move "${srcNode.title.slice(0,40)}..." to be a child of its descendant "${focusedNode.title.slice(0,40)}...".\n\n` +
              `This will reorganize the tree hierarchy by promoting "${focusedNode.title.slice(0,40)}..." to be the new parent.\n\n` +
              `Do you want to proceed with this reorganization?`
            );
            
            if(shouldReorganize) {
              reorganizeTreeForCircularMove(srcId, state.focusId);
              pushHistory(); renderAll(); toast("Tree reorganized to avoid circular dependency","ok");
            } else {
              toast("Move cancelled by user","info");
            }
          } else {
            moveAsChild(srcId, state.focusId);
            pushHistory(); renderAll(); toast("Moved as child","ok");
          }
        }
        if(list === treeParent && parent && parent.parentId){
          reorderIntoSiblingPosition(srcId, parent.id);
          pushHistory(); renderAll(); toast("Moved near parent","ok");
        }
      });
    });
  }

  function button(txt, cls, fn){
    const b = document.createElement("button"); b.textContent = txt; if(cls) b.className = cls; b.addEventListener("click", fn); return b;
  }

  function duplicateNode(id){
    const n = state.nodes[id];
    const copyId = uid();
    const copy = deepClone(n);
    copy.id = copyId;
    copy.children = (n.children||[]).map(childId => duplicateSubtree(childId));
    copy.title = (n.title||"") + " (copy)";
    state.nodes[copyId] = copy;
    const list = state.nodes[n.parentId].children;
    const idx = list.indexOf(n.id);
    list.splice(idx+1,0, copyId);
    copy.parentId = n.parentId;
    pushHistory(); renderAll(); toast("Duplicated","ok");
  }
  function duplicateSubtree(id){
    const n = state.nodes[id];
    const newId = uid();
    const copy = deepClone(n);
    copy.id = newId;
    copy.children = (n.children||[]).map(childId => duplicateSubtree(childId));
    state.nodes[newId] = copy;
    copy.parentId = null;
    return newId;
  }
  function unlinkNode(id){
    const n = state.nodes[id];
    if(!n.linkTo) return toast("Not a link","warn");
    delete n.linkTo;
    pushHistory(); renderAll(); toast("Unlinked","ok");
  }
  function deleteNodeWithConfirm(id){
    const n = state.nodes[id];
    if(!n) return;
    if(n.children && n.children.length>0){
      if(!confirm("This node has children. Delete entire subtree?")) return;
    }
    deleteSubtree(id);
    const parent = state.nodes[n.parentId];
    if(parent){ parent.children = parent.children.filter(x=>x!==id); }
    if(state.focusId === id) state.focusId = state.rootId;
    pushHistory(); renderAll(); toast("Deleted","ok");
  }
  function deleteSubtree(id){
    const n = state.nodes[id];
    if(!n) return;
    (n.children||[]).forEach(deleteSubtree);
    delete state.nodes[id];
  }

  // ---------- Categories ----------
  const catList = $("#category-list");
  $("#btn-add-category").addEventListener("click", ()=>{
    const name = $("#new-cat-name").value.trim() || "New Category";
    const color = $("#new-cat-color").value || "#00aa88";
    const id = uid();
    state.categories[id] = {id, name, colorHex: color};
    state.catOrder.push(id);
    pushHistory(); renderCategories(); renderRings(); saveToStorage();
  });

  function renderCategories(){
    catList.innerHTML = "";
    state.catOrder.forEach(cid=>{
      const c = state.categories[cid];
      const row = document.createElement("div");
      row.className = "category-horizontal"; 
      row.dataset.id = cid;
      row.draggable = true;
      
      // Drag start handler
      row.addEventListener("dragstart", (e)=>{
        e.dataTransfer.setData("application/x-category-id", cid);
        e.dataTransfer.effectAllowed = "move";
        row.classList.add("dragging");
      });
      
      // Drag end handler
      row.addEventListener("dragend", (e)=>{
        row.classList.remove("dragging");
        // Remove any placeholder
        const placeholder = catList.querySelector(".category-drag-placeholder");
        if(placeholder) placeholder.remove();
      });
      
      // Drag over handler
      row.addEventListener("dragover", (e)=>{
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
        
        // Get or create placeholder
        let placeholder = catList.querySelector(".category-drag-placeholder");
        if(!placeholder){
          placeholder = document.createElement("div");
          placeholder.className = "category-drag-placeholder";
        }
        
        // Determine if we should insert before or after this element
        const rect = row.getBoundingClientRect();
        const midpoint = rect.left + rect.width / 2;
        const insertBefore = e.clientX < midpoint;
        
        // Insert placeholder at the appropriate position
        if(insertBefore){
          row.parentNode.insertBefore(placeholder, row);
        } else {
          // Insert after current element
          if(row.nextSibling){
            row.parentNode.insertBefore(placeholder, row.nextSibling);
          } else {
            row.parentNode.appendChild(placeholder);
          }
        }
      });
      
      // Drag leave handler
      row.addEventListener("dragleave", (e)=>{
        // Keep placeholder visible during drag operation
      });
      
      // Drop handler
      row.addEventListener("drop", (e)=>{
        e.preventDefault();
        
        const draggedId = e.dataTransfer.getData("application/x-category-id");
        if(!draggedId || draggedId === cid) {
          // Remove placeholder
          const placeholder = catList.querySelector(".category-drag-placeholder");
          if(placeholder) placeholder.remove();
          return;
        }
        
        // Get current positions
        const draggedIndex = state.catOrder.indexOf(draggedId);
        const targetIndex = state.catOrder.indexOf(cid);
        
        if(draggedIndex === -1 || targetIndex === -1) {
          // Remove placeholder
          const placeholder = catList.querySelector(".category-drag-placeholder");
          if(placeholder) placeholder.remove();
          return;
        }
        
        // Determine insertion position based on where placeholder is
        const placeholder = catList.querySelector(".category-drag-placeholder");
        let insertIndex;
        
        if(placeholder){
          // Find the index where placeholder is positioned
          const allElements = Array.from(catList.children);
          const placeholderIndex = allElements.indexOf(placeholder);
          
          // Count how many category elements are before the placeholder
          let categoryCountBefore = 0;
          for(let i = 0; i < placeholderIndex; i++){
            if(allElements[i].classList.contains("category-horizontal")){
              categoryCountBefore++;
            }
          }
          
          // Adjust for the dragged item if it's before the target position
          insertIndex = categoryCountBefore;
          if(draggedIndex < categoryCountBefore){
            insertIndex--;
          }
          
          placeholder.remove();
        } else {
          // Fallback to old logic if no placeholder
          if(draggedIndex < targetIndex){
            insertIndex = targetIndex;
          } else {
            insertIndex = targetIndex + 1;
          }
        }
        
        // Remove dragged item from array
        state.catOrder.splice(draggedIndex, 1);
        
        // Insert at calculated position
        state.catOrder.splice(insertIndex, 0, draggedId);
        
        pushHistory(); 
        renderCategories(); 
        saveToStorage();
        toast("Category reordered","ok");
      });
      
      // Create drag handle icon
      const dragHandle = document.createElement("div");
      dragHandle.className = "drag-handle";
      dragHandle.setAttribute("aria-label", "Drag to reorder");
      // Create three horizontal lines for the grip icon
      for(let i = 0; i < 3; i++){
        const line = document.createElement("div");
        line.className = "drag-handle-line";
        dragHandle.appendChild(line);
      }
      
      const color = document.createElement("input"); 
      color.type="color"; 
      color.value = c.colorHex;
      color.addEventListener("input", ()=>{ c.colorHex=color.value; renderRings(); saveToStorage(); });
      
      const name = document.createElement("div"); 
      name.className="name"; 
      name.contentEditable="true"; 
      name.textContent = c.name;
      name.addEventListener("blur", ()=>{ c.name = name.textContent.trim() || c.name; renderTree(); renderRings(); saveToStorage(); });

      const actionsInline = document.createElement("div");
      actionsInline.className = "category-actions-inline";
      
      const del = button("×","small danger", ()=>{
        const inUse = Object.values(state.nodes).some(n=> n.categoryId===cid);
        if(inUse) return toast("Category in use","warn");
        delete state.categories[cid];
        state.catOrder = state.catOrder.filter(x=>x!==cid);
        pushHistory(); renderCategories();
      });
      del.setAttribute("aria-label", "Delete category");

      actionsInline.append(del);
      row.append(dragHandle, color, name, actionsInline);
      catList.appendChild(row);
    });
  }
  
  // Add dragover handler to the category list container
  catList.addEventListener("dragover", (e)=>{
    // Only handle if dragging a category
    if(!e.dataTransfer.types.includes("application/x-category-id")) return;
    e.preventDefault();
    
    // If dragging over empty space (not over a category), show placeholder at the end
    const target = e.target;
    if(target === catList || target.classList.contains("category-list-horizontal")){
      let placeholder = catList.querySelector(".category-drag-placeholder");
      if(!placeholder){
        placeholder = document.createElement("div");
        placeholder.className = "category-drag-placeholder";
      }
      // Append to end of list
      catList.appendChild(placeholder);
    }
  });
  
  // Add drop handler to the category list container for dropping at the end
  catList.addEventListener("drop", (e)=>{
    // Only handle if dragging a category and dropped on empty space
    if(!e.dataTransfer.types.includes("application/x-category-id")) return;
    
    const target = e.target;
    if(target !== catList && !target.classList.contains("category-list-horizontal")) return;
    
    e.preventDefault();
    
    const draggedId = e.dataTransfer.getData("application/x-category-id");
    if(!draggedId) {
      const placeholder = catList.querySelector(".category-drag-placeholder");
      if(placeholder) placeholder.remove();
      return;
    }
    
    // Get placeholder position to determine where to insert
    const placeholder = catList.querySelector(".category-drag-placeholder");
    if(placeholder){
      const allElements = Array.from(catList.children);
      const placeholderIndex = allElements.indexOf(placeholder);
      
      // Count how many category elements are before the placeholder
      let categoryCountBefore = 0;
      for(let i = 0; i < placeholderIndex; i++){
        if(allElements[i].classList.contains("category-horizontal")){
          categoryCountBefore++;
        }
      }
      
      const draggedIndex = state.catOrder.indexOf(draggedId);
      
      // Adjust for the dragged item if it's before the target position
      let insertIndex = categoryCountBefore;
      if(draggedIndex < categoryCountBefore){
        insertIndex--;
      }
      
      placeholder.remove();
      
      // Remove dragged item from array
      state.catOrder.splice(draggedIndex, 1);
      
      // Insert at calculated position
      state.catOrder.splice(insertIndex, 0, draggedId);
      
      pushHistory(); 
      renderCategories(); 
      saveToStorage();
      toast("Category reordered","ok");
    }
  });

  // ---------- Modals ----------
  const editDialog = $("#edit-argument-dialog");
  const newDialog = $("#new-argument-dialog");
  const linkDialog = $("#link-argument-dialog");
  const chunkDropDialog = $("#chunk-drop-dialog");
  const nodeDropDialog = $("#node-drop-dialog");

  function fillCategorySelect(sel, selectedId){
    sel.innerHTML = "";
    state.catOrder.forEach(cid=>{
      const opt = document.createElement("option");
      opt.value = cid; opt.textContent = state.categories[cid].name;
      if(cid === selectedId) opt.selected = true;
      sel.appendChild(opt);
    });
  }

  function openEditModal(id){
    const n = state.nodes[id];
    $("#edit-title").value = n.linkTo && state.nodes[n.linkTo] ? state.nodes[n.linkTo].title : (n.title||"");
    fillCategorySelect($("#edit-category"), n.categoryId);
    $("#edit-rating").value = String(n.rating || 3);
    $("#edit-rating-value").textContent = String(n.rating || 3);
    $("#delete-warning").hidden = !(n.children && n.children.length>0);

    $("#edit-rating").oninput = ()=> $("#edit-rating-value").textContent = $("#edit-rating").value;

    $("#btn-save-node").onclick = (e)=>{
      e.preventDefault();
      const t = $("#edit-title").value.trim();
      const cat = $("#edit-category").value;
      const r = parseInt($("#edit-rating").value, 10);
      if(n.linkTo && state.nodes[n.linkTo]){
        state.nodes[n.linkTo].title = t;
      } else {
        n.title = t;
      }
      n.categoryId = cat; n.rating = r;
      editDialog.close();
      pushHistory(); renderAll(); toast("Saved","ok");
    };
    $("#btn-delete-node").onclick = ()=>{ editDialog.close(); deleteNodeWithConfirm(id); };

    if(typeof editDialog.showModal === "function"){ editDialog.showModal(); }
    else { alert("Your browser does not support <dialog>."); }
  }

  let newModalContext = null;
  function openNewModal(ctx){
    newModalContext = ctx;
    $("#new-title").value = (ctx && ctx.presetText) ? ctx.presetText : "";
    fillCategorySelect($("#new-category"), state.catOrder[0]);
    $("#new-rating").value = "3"; $("#new-rating-value").textContent = "3";
    if(typeof newDialog.showModal === "function"){ newDialog.showModal(); } else { alert("No dialog support"); }
  }
  $("#btn-create-node").addEventListener("click", (e)=>{
    e.preventDefault();
    const title = $("#new-title").value.trim();
    if(!title){ toast("Title required","err"); return; }
    const categoryId = $("#new-category").value;
    const rating = parseInt($("#new-rating").value, 10);
    const id = uid();
    const n = { id, title, categoryId, rating, children:[], parentId:null };
    const ref = state.nodes[newModalContext.refId];
    if(newModalContext.mode === "child"){
      n.parentId = ref.id; ref.children.push(id);
    } else {
      const parent = state.nodes[ref.parentId];
      const idx = parent.children.indexOf(ref.id);
      n.parentId = parent.id;
      parent.children.splice(idx+1, 0, id);
    }
    state.nodes[id] = n;
    newDialog.close();
    pushHistory(); renderAll(); toast("Created","ok");
  });

  let linkContext = null;
  function openLinkModal(targetId){
    linkContext = targetId;
    const sel = $("#link-node-select");
    sel.innerHTML = "";
    Object.values(state.nodes).forEach(n=>{
      if(n.id === targetId) return;
      const opt = document.createElement("option");
      opt.value = n.id; opt.textContent = n.title;
      sel.appendChild(opt);
    });
    if(typeof linkDialog.showModal === "function"){ linkDialog.showModal(); }
  }
  $("#btn-link-node").addEventListener("click", (e)=>{
    e.preventDefault();
    const target = state.nodes[linkContext];
    const linkTo = $("#link-node-select").value;
    if(!state.nodes[linkTo]) return toast("Invalid link target","err");
    target.linkTo = linkTo;
    linkDialog.close();
    pushHistory(); renderAll(); toast("Linked","ok");
  });

  // ---------- Chunking Inbox ----------
  const inboxList = $("#chunk-list");
  function renderInbox(){
    inboxList.innerHTML = "";
    state.inbox.forEach((ch, idx)=>{
      const row = document.createElement("div");
      row.className = "chunk";
      row.draggable = true;
      row.dataset.id = ch.id;
      row.addEventListener("dragstart", (e)=>{
        e.dataTransfer.setData("application/x-chunk-id", ch.id);
        e.dataTransfer.effectAllowed = "copyMove";
      });

      const text = document.createElement("div");
      text.className = "text";
      text.textContent = ch.text;
      text.contentEditable = "true";
      text.addEventListener("blur", ()=>{
        const t = text.textContent.trim();
        ch.text = t;
        saveToStorage();
      });

      const actions = document.createElement("div");
      actions.className = "row-actions";
      actions.append(
        spanTag(`#${idx+1}`),
        button("Combine ↑", "small", ()=> combineWithPrev(idx)),
        button("Duplicate", "small", ()=> duplicateChunk(ch.id)),
        button("Delete", "small danger", ()=> deleteChunk(ch.id))
      );

      row.append(text, actions);
      inboxList.appendChild(row);
    });
  }
  function spanTag(t){ const s=document.createElement("span"); s.className="tag"; s.textContent=t; return s; }
  function combineWithPrev(idx){
    if(idx<=0) return;
    const a = state.inbox[idx-1], b = state.inbox[idx];
    a.text = (a.text.trim() + " " + b.text.trim()).trim();
    state.inbox.splice(idx,1);
    pushHistory(); renderInbox(); toast("Combined","ok");
  }
  function duplicateChunk(id){
    const ch = state.inbox.find(x=>x.id===id);
    const copy = { id: uid(), text: ch.text };
    state.inbox.splice(state.inbox.indexOf(ch)+1,0, copy);
    pushHistory(); renderInbox(); toast("Duplicated","ok");
  }
  function deleteChunk(id){
    state.inbox = state.inbox.filter(x=>x.id!==id);
    pushHistory(); renderInbox(); toast("Deleted","ok");
  }

  $("#btn-clear-inbox").addEventListener("click", ()=>{
    if(confirm("Clear all chunks?")){ state.inbox = []; pushHistory(); renderInbox(); }
  });

  $("#btn-smart-chunk").addEventListener("click", ()=>{
    const raw = $("#chunk-input").value;
    if(!raw || !raw.trim()) return toast("Paste text first","warn");
    const chunks = smartChunk(raw);
    chunks.forEach(t=> state.inbox.push({id: uid(), text: t}));
    $("#chunk-input").value = "";
    pushHistory(); renderInbox(); toast(`Chunked into ${chunks.length} items`,"ok");
  });

  function smartChunk(text){
    const markers = /\b(therefore|however|moreover|consequently|furthermore|nevertheless|nonetheless|thus|hence|but|and yet)\b/gi;
    const lines = text.split(/\r?\n/);
    const items = [];
    for(let ln of lines){
      ln = ln.trim();
      if(!ln) continue;
        if (/^(\*|-|\d+[\.\)])\s+/.test(ln)) {
        items.push(ln);
        continue;
      }
      let parts = ln.split(/(?<=[\.\?\!])\s+|—|–|;|:|\.\.\./).flatMap(s => s.split(markers)).map(s=>s.trim()).filter(Boolean);
      items.push(...parts);
    }
    const merged = [];
    let buf = null;
    for(const it of items){
      if(!buf){ buf = it; continue; }
      if(buf.length < 60) { buf = (buf + " " + it).trim(); }
      else { merged.push(buf); buf = it; }
    }
    if(buf) merged.push(buf);
    return merged;
  }

  // ---------- Chunk -> Ring Drop ----------
  svg.addEventListener("dragover", (e)=>{
    // Check if this is a chunk or node drag (can't use getData during dragover)
    if(!e.dataTransfer.types.includes("application/x-chunk-id") && 
       !e.dataTransfer.types.includes("application/x-node-id")) return;
    e.preventDefault();
    const pt = svgPoint(e);
    const target = pickSegmentAt(pt.x, pt.y);
    
    console.log("=== DRAGOVER EVENT ===");
    console.log("SVG point:", pt.x, pt.y);
    console.log("Regular segment target:", target);
    console.log("Placeholders available:", viewport._placeholders ? viewport._placeholders.length : 'none');

    
    // Clear previous highlights
    if(viewport._lastChunkTarget && viewport._lastChunkTarget.el) viewport._lastChunkTarget.el.classList.remove("drop-target");
    if(viewport._lastPlaceholderTarget) {
      viewport._lastPlaceholderTarget.classList.remove("drop-target");
      if(viewport._lastPlaceholderTarget._plusIcon) {
        viewport._lastPlaceholderTarget._plusIcon.classList.remove("drop-target");
      }
    }
    
    // Highlight regular segments for sibling drop
    if(target){ 
      target.el.classList.add("drop-target"); 
      viewport._lastChunkTarget = target;
      viewport._lastPlaceholderTarget = null;
    } else {
      viewport._lastChunkTarget = null;
      
      // Check placeholder segments for child drop
      let hoveredPlaceholder = null;
      for(const ph of viewport._placeholders||[]){
        const parentId = ph._parentId;
        const layout = buildHierarchy(state.rootId)[parentId];
        if(!layout) continue;
        
        const r = Math.hypot(pt.x, pt.y);
        const angle = Math.atan2(pt.y, pt.x);
        const normAngle = angle>=0 ? angle : (2*Math.PI + angle);
        const childDepth = getDepthOf(parentId) + 1;
        const r0 = ringWidth * 0.5;
        const childRInner = r0 + (childDepth-1)*(ringWidth + ringGap);
        const childROuter = childRInner + ringWidth;
        
        if(r >= childRInner && r <= childROuter + 1 && normAngle >= layout.a0 && normAngle <= layout.a1){
          ph.classList.add("drop-target");
          if(ph._plusIcon) ph._plusIcon.classList.add("drop-target");
          hoveredPlaceholder = ph;
          break;
        }
      }
      viewport._lastPlaceholderTarget = hoveredPlaceholder;
    }
  });
  svg.addEventListener("dragleave", ()=>{
    if(viewport._lastChunkTarget && viewport._lastChunkTarget.el) viewport._lastChunkTarget.el.classList.remove("drop-target");
    if(viewport._lastPlaceholderTarget) {
      viewport._lastPlaceholderTarget.classList.remove("drop-target");
      if(viewport._lastPlaceholderTarget._plusIcon) {
        viewport._lastPlaceholderTarget._plusIcon.classList.remove("drop-target");
      }
    }
    viewport._lastChunkTarget = null;
    viewport._lastPlaceholderTarget = null;
  });
  svg.addEventListener("drop", (e)=>{
    const chunkId = e.dataTransfer.getData("application/x-chunk-id");
    const nodeId = e.dataTransfer.getData("application/x-node-id");
    
    console.log("=== SVG DROP EVENT ===");
    console.log("chunkId:", chunkId);
    console.log("nodeId:", nodeId);
    console.log("dataTransfer.types:", e.dataTransfer.types);
    
    if(!chunkId && !nodeId) {
      console.log("❌ No chunkId or nodeId found, returning early");
      return;
    }
    e.preventDefault();

    // Clear all highlights
    if(viewport._lastChunkTarget && viewport._lastChunkTarget.el) viewport._lastChunkTarget.el.classList.remove("drop-target");
    if(viewport._lastPlaceholderTarget) {
      viewport._lastPlaceholderTarget.classList.remove("drop-target");
      if(viewport._lastPlaceholderTarget._plusIcon) {
        viewport._lastPlaceholderTarget._plusIcon.classList.remove("drop-target");
      }
    }

    // Handle chunk drops
    if(chunkId) {
      const chIdx = state.inbox.findIndex(c=>c.id===chunkId);
      if(chIdx<0) { toast("Chunk already used or missing","warn"); return; }
      const chunk = state.inbox[chIdx];

      // Check for placeholder drop (add as child)
      const placeholderTarget = viewport._lastPlaceholderTarget;
      if(placeholderTarget) {
        const parentId = placeholderTarget._parentId;
        const newId = uid();
        state.nodes[newId] = {
          id: newId,
          title: chunk.text.trim().slice(0, 240),
          categoryId: state.catOrder[0],
          rating: 3,
          children:[],
          parentId: parentId,
        };
        const parent = state.nodes[parentId];
        if(!parent.children) parent.children = [];
        parent.children.push(newId);
        state.inbox.splice(chIdx,1);
        state.consumedChunkIds[chunk.id] = true;
        viewport._lastPlaceholderTarget = null;
        pushHistory();
        renderInbox(); renderAll();
        toast("Added as child and removed from inbox","ok");
        return;
      }

      // Check for regular segment drop (show dialog to choose between sibling or combine)
      const target = viewport._lastChunkTarget || (()=>{
        const pt = svgPoint(e); return pickSegmentAt(pt.x, pt.y);
      })();

      if(!target){ 
        toast("Drop onto a segment or placeholder ring to add argument","warn"); 
        viewport._lastChunkTarget = null;
        return; 
      }

      const targetNode = state.nodes[target.id];
      viewport._lastChunkTarget = null;

      // Show dialog to let user choose between adding as sibling or combining
      $("#chunk-drop-message").textContent = `How would you like to add this chunk to "${targetNode.title.slice(0, 50)}${targetNode.title.length > 50 ? '...' : ''}"?`;
      
      // Store context for dialog handlers
      const dropContext = {
        chunkId,
        chIdx,
        chunk,
        targetNode,
      };

      // Set up dialog button handlers
      $("#btn-chunk-sibling").onclick = (evt)=>{
        evt.preventDefault();
        const parent = state.nodes[dropContext.targetNode.parentId];
        const newId = uid();
        state.nodes[newId] = {
          id: newId,
          title: dropContext.chunk.text.trim().slice(0, 240),
          categoryId: state.catOrder[0],
          rating: 3,
          children:[],
          parentId: parent.id,
        };
        const idx = parent.children.indexOf(dropContext.targetNode.id);
        parent.children.splice(idx+1, 0, newId);

        state.inbox.splice(dropContext.chIdx,1);
        state.consumedChunkIds[dropContext.chunk.id] = true;

        chunkDropDialog.close();
        pushHistory();
        renderInbox(); renderAll();
        toast("Added as sibling and removed from inbox","ok");
      };

      $("#btn-chunk-combine").onclick = (evt)=>{
        evt.preventDefault();
        // Combine the chunk text with the existing node's title
        const existingTitle = dropContext.targetNode.title || "";
        const chunkText = dropContext.chunk.text.trim();
        
        // Combine with a space separator
        dropContext.targetNode.title = (existingTitle + " " + chunkText).trim();

        state.inbox.splice(dropContext.chIdx,1);
        state.consumedChunkIds[dropContext.chunk.id] = true;

        chunkDropDialog.close();
        pushHistory();
        renderInbox(); renderAll();
        toast("Combined with existing node and removed from inbox","ok");
      };

      // Show the dialog
      if(typeof chunkDropDialog.showModal === "function"){ 
        chunkDropDialog.showModal(); 
      } else { 
        alert("Your browser does not support <dialog>."); 
      }
    }

    // Handle node drops
    if(nodeId) {
      const sourceNode = state.nodes[nodeId];
      if(!sourceNode) { toast("Source node not found","warn"); return; }

      // Check for placeholder drop (move as child)
      let placeholderTarget = viewport._lastPlaceholderTarget;
      console.log("=== NODE DROP HANDLER ===");
      console.log("Initial placeholderTarget:", placeholderTarget);
      
      // If no placeholder was detected during dragover, try to detect one now at drop coordinates
      if(!placeholderTarget) {
        console.log("=== FALLBACK PLACEHOLDER DETECTION ===");
        // Use the same coordinate transformation as svgPoint
        const pt = svg.createSVGPoint();
        pt.x = e.clientX; pt.y = e.clientY;
        const inv = viewport.getScreenCTM().inverse();
        const svgPt = pt.matrixTransform(inv);
        
        console.log("Drop coordinates:", e.clientX, e.clientY);
        console.log("SVG coordinates:", svgPt.x, svgPt.y);
        
        const layout = buildHierarchy(state.rootId);
        const r0 = ringWidth * 0.5;
        
        console.log("Ring geometry: r0 =", r0, "ringWidth =", ringWidth, "ringGap =", ringGap);
        
        // Check all childless nodes to see if drop coordinates match their placeholder rings
        for(const [parentId, l] of Object.entries(layout)) {
          const parentNode = state.nodes[parentId];
          const hasChildren = parentNode.children && parentNode.children.length > 0;
          console.log(`Checking node ${parentId}: depth=${l.depth}, hasChildren=${hasChildren}, a0=${l.a0}, a1=${l.a1}`);
          
          if(!hasChildren) {
            const childDepth = l.depth + 1;
            const childRInner = r0 + (childDepth-1)*(ringWidth + ringGap);
            const childROuter = childRInner + ringWidth;
            
            const r = Math.hypot(svgPt.x, svgPt.y);
            const angle = Math.atan2(svgPt.y, svgPt.x);
            const normAngle = angle >= 0 ? angle : (2*Math.PI + angle);
            
            console.log(`  Placeholder ring: childDepth=${childDepth}, rInner=${childRInner}, rOuter=${childROuter}`);
            console.log(`  Drop point: r=${r}, angle=${normAngle}`);
            console.log(`  Bounds check: r in [${childRInner}, ${childROuter + 1}] = ${r >= childRInner && r <= childROuter + 1}`);
            console.log(`  Angle check: angle in [${l.a0}, ${l.a1}] = ${normAngle >= l.a0 && normAngle <= l.a1}`);
            
            if(r >= childRInner && r <= childROuter + 1 && normAngle >= l.a0 && normAngle <= l.a1) {
              placeholderTarget = { _parentId: parentId };
              console.log("✅ DETECTED placeholder at drop time for parent:", parentId);
              break;
            }
          }
        }
        
        if(!placeholderTarget) {
          console.log("❌ No placeholder found at drop coordinates");
        }
      }
      
      if(placeholderTarget) {
        const newParentId = placeholderTarget._parentId;
        const newParent = state.nodes[newParentId];
        
        // Check for circular dependency (moving a node to be a child of its descendant)
        if(isDescendant(newParentId, nodeId)) {
          // Show warning and ask for confirmation
          const shouldReorganize = confirm(
            `⚠️ Warning: You are trying to move "${sourceNode.title.slice(0,50)}..." to be a child of its own descendant "${newParent.title.slice(0,50)}...".\n\n` +
            `This will reorganize the tree hierarchy by promoting "${newParent.title.slice(0,50)}..." to be the new parent.\n\n` +
            `Do you want to proceed with this reorganization?`
          );
          
          if(!shouldReorganize) {
            toast("Move cancelled by user","info");
            viewport._lastPlaceholderTarget = null;
            return;
          }
          
          // Perform tree reorganization to avoid circular dependency
          reorganizeTreeForCircularMove(nodeId, newParentId);
          toast("Tree reorganized to avoid circular dependency","ok");
        } else {
          // Normal move operation
          moveAsChild(nodeId, newParentId);
          toast("Moved as child","ok");
        }
        
        viewport._lastPlaceholderTarget = null;
        pushHistory();
        renderAll();
        return;
      }

      // Check for regular segment drop (move as sibling)
      const target = viewport._lastChunkTarget || (()=>{
        const pt = svgPoint(e); return pickSegmentAt(pt.x, pt.y);
      })();
      
      if(target) {
        const targetNode = state.nodes[target.id];
        if(!targetNode) { toast("Target node not found","warn"); return; }
        
        // Check for circular dependency in sibling move
        if(isDescendant(target.id, nodeId)) {
          const sourceNode = state.nodes[nodeId];
          const shouldProceed = confirm(
            `⚠️ Cross-Generation Sibling Warning\n\n` +
            `You are trying to move "${sourceNode.title.slice(0,40)}..." to be a sibling of its descendant "${targetNode.title.slice(0,40)}...".\n\n` +
            `This will create a complex tree reorganization. Do you want to proceed?`
          );
          
          if(!shouldProceed) {
            toast("Move cancelled by user","info");
            viewport._lastChunkTarget = null;
            return;
          }
          
          // Proceed with the move - the complex reorganization will be handled
          toast("Complex cross-generation move completed","ok");
        }
        
        reorderIntoSiblingPosition(nodeId, target.id);
        viewport._lastChunkTarget = null;
        pushHistory();
        renderAll();
        toast("Moved as sibling","ok");
        return;
      }
      
      toast("No valid drop target found","warn");
    }
  });

  // ---------- Import / Export ----------
  $("#btn-export").addEventListener("click", ()=>{
    const blob = new Blob([ JSON.stringify(exportState(false), null, 2) ], {type: "application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `argument-rings-${new Date().toISOString().slice(0,19)}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
  });
  $("#btn-import").addEventListener("click", ()=> $("#file-input").click());
  $("#file-input").addEventListener("change", (e)=>{
    const f = e.target.files[0];
    if(!f) return;
    const reader = new FileReader();
    reader.onload = ()=> {
      try{
        const obj = JSON.parse(reader.result);
        importState(obj);
        pushHistory();
        renderAll();
        toast("Imported","ok");
      }catch(err){
        toast("Invalid JSON","err");
      }
    };
    reader.readAsText(f);
    e.target.value="";
  });

  function exportState(internal=false){
    return {
      categories: state.categories,
      catOrder: state.catOrder,
      nodes: state.nodes,
      rootId: state.rootId,
      focusId: state.focusId,
      inbox: state.inbox,
      consumedChunkIds: state.consumedChunkIds,
      view: state.view,
      _meta: internal ? { savedAt: now() } : undefined
    };
  }
  function importState(obj, opts={}){
    ["categories","catOrder","nodes","rootId"].forEach(k=>{
      if(!obj[k]) throw new Error("Missing key "+k);
    });
    Object.assign(state, deepClone(obj));
    state.view = state.view || {panX:0,panY:0,zoom:1};
    if(!opts.silent) toast("State loaded","ok");
    renderCategories();
  }

  // ---------- Keyboard ----------
  window.addEventListener("keydown", (e)=>{
    if(e.key==="Escape"){
      [editDialog,newDialog,linkDialog,chunkDropDialog,nodeDropDialog].forEach(d=> d.open && d.close());
    }
  });

  // ---------- Init ----------
  (function init(){
    // Load projects first
    projects = loadProjects();
    currentProjectId = getCurrentProjectId();
    
    // If we have a current project, load it
    if(currentProjectId && projects[currentProjectId]){
      const project = projects[currentProjectId];
      if(project.data){
        try{ importState(project.data, {silent:true}); }catch{}
      }
    } else {
      // Otherwise load from old storage format
      const saved = loadFromStorage();
      if(saved){ try{ importState(saved, {silent:true}); }catch{} }
    }
    
    ensureDefaults();
    renderCategories();
    renderProjects();
    homeView();
    applyView();
    renderAll();
    pushHistory();
  })();

  // ---------- Panel Minimize/Expand ----------
  const PANEL_STATE_KEY = "argumentRingsPanelStates_v1";
  
  function loadPanelStates() {
    const raw = localStorage.getItem(PANEL_STATE_KEY);
    if(!raw) return { projects: false, inbox: false, tree: false };
    try { 
      return JSON.parse(raw); 
    } catch { 
      return { projects: false, inbox: false, tree: false }; 
    }
  }
  
  function savePanelStates() {
    const states = {
      projects: $("#projects-panel").classList.contains("minimized"),
      inbox: $("#inbox-panel").classList.contains("minimized"),
      tree: $("#tree-panel").classList.contains("minimized")
    };
    localStorage.setItem(PANEL_STATE_KEY, JSON.stringify(states));
  }
  
  function togglePanel(panelName, panel, btn, appContainer) {
    const isMinimized = panel.classList.toggle("minimized");
    
    if(isMinimized) {
      appContainer.dataset[`${panelName}Minimized`] = "true";
      btn.textContent = panelName === "tree" ? "◀" : "▶";
      btn.title = "Expand panel";
    } else {
      appContainer.dataset[`${panelName}Minimized`] = "false";
      btn.textContent = panelName === "tree" ? "▶" : "◀";
      btn.title = "Minimize panel";
    }
    
    savePanelStates();
  }
  
  function initPanelToggles() {
    const savedStates = loadPanelStates();
    const appContainer = document.querySelector(".app");
    
    // Projects panel
    const projectsPanel = $("#projects-panel");
    const projectsBtn = $("#toggle-projects");
    if(savedStates.projects) {
      projectsPanel.classList.add("minimized");
      appContainer.dataset.projectsMinimized = "true";
      projectsBtn.textContent = "▶";
      projectsBtn.title = "Expand panel";
    }
    projectsBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      togglePanel("projects", projectsPanel, projectsBtn, appContainer);
    });
    projectsPanel.querySelector("h2").addEventListener("click", () => {
      if(projectsPanel.classList.contains("minimized")) {
        togglePanel("projects", projectsPanel, projectsBtn, appContainer);
      }
    });
    
    // Inbox panel
    const inboxPanel = $("#inbox-panel");
    const inboxBtn = $("#toggle-inbox");
    if(savedStates.inbox) {
      inboxPanel.classList.add("minimized");
      appContainer.dataset.inboxMinimized = "true";
      inboxBtn.textContent = "▶";
      inboxBtn.title = "Expand panel";
    }
    inboxBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      togglePanel("inbox", inboxPanel, inboxBtn, appContainer);
    });
    inboxPanel.querySelector("h2").addEventListener("click", () => {
      if(inboxPanel.classList.contains("minimized")) {
        togglePanel("inbox", inboxPanel, inboxBtn, appContainer);
      }
    });
    
    // Tree panel
    const treePanel = $("#tree-panel");
    const treeBtn = $("#toggle-tree");
    if(savedStates.tree) {
      treePanel.classList.add("minimized");
      appContainer.dataset.treeMinimized = "true";
      treeBtn.textContent = "◀";
      treeBtn.title = "Expand panel";
    }
    treeBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      togglePanel("tree", treePanel, treeBtn, appContainer);
    });
    treePanel.querySelector("h2").addEventListener("click", () => {
      if(treePanel.classList.contains("minimized")) {
        togglePanel("tree", treePanel, treeBtn, appContainer);
      }
    });
  }
  
  // Initialize panel toggles after DOM is ready
  initPanelToggles();

  function renderAll(){
    applyView();
    renderRings();
    renderTree();
    renderInbox();
    saveToStorage();
  }

  // Click-through focus sync
  viewport.addEventListener("click", (e)=>{
    const path = e.target.closest(".segment");
    if(path){
      const id = path.dataset.id;
      focusNode(id);
    }
  });

  // Chunks drop on tree lists too
  [treeParent, treeSiblings, treeChildren].forEach(list=>{
    list.addEventListener("dragover", (e)=>{
      const chunkId = e.dataTransfer.getData("application/x-chunk-id");
      if(chunkId){ e.preventDefault(); }
    });
    list.addEventListener("drop", (e)=>{
      const chunkId = e.dataTransfer.getData("application/x-chunk-id");
      if(!chunkId) return;
      e.preventDefault();

      const chIdx = state.inbox.findIndex(c=>c.id===chunkId);
      if(chIdx<0) return toast("Chunk missing","warn");
      const chunk = state.inbox[chIdx];
      let parentId = null;

      if(list===treeChildren){ parentId = state.focusId; }
      if(list===treeSiblings){
        const p = state.nodes[state.nodes[state.focusId].parentId];
        parentId = p ? p.id : state.rootId;
      }
      if(list===treeParent){
        const parent = state.nodes[state.focusId].parentId;
        const grand = parent ? state.nodes[parent].parentId : state.rootId;
        parentId = grand || state.rootId;
      }

      const newId = uid();
      state.nodes[newId] = {
        id:newId, title: chunk.text.trim().slice(0,240),
        categoryId: state.catOrder[0], rating:3, children:[], parentId
      };
      const arr = state.nodes[parentId].children;
      arr.push(newId);

      state.inbox.splice(chIdx,1);
      state.consumedChunkIds[chunk.id]=true;

      pushHistory(); renderAll();
      toast("Chunk added and removed from inbox","ok");
    });
  });

})();

  </script>
</body>
</html>
